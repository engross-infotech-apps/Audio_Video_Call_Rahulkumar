import 'dart:async';
import 'dart:io';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/services.dart';
import 'package:flutter_callkit_incoming/entities/android_params.dart';
import 'package:flutter_callkit_incoming/entities/call_kit_params.dart';
import 'package:flutter_callkit_incoming/flutter_callkit_incoming.dart';
import 'package:get/get.dart';
import 'package:permission_handler/permission_handler.dart';

class CallingController extends GetxController {
  static const appId = "7eb4f36c089a4d3aa563555e8f36940c";

  // Fill in the temporary token generated from Agora Console
  static const token =
      "007eJxTYPDYO/8eS4rtzf9qrjLLd2pMnCdyOnPjFVG2N88KkjK+bs9XYDBPTTJJMzZLNrCwTDRJMU5MNDUzNjU1TbUAClqaGCQv+f0wvSGQkeFAuCUTIwMEgvgiDMkZiXl5qTnx6fnZmSml8UWJGaU5DAwA4tYnVA==";

  // server agora API that will token.

  // Fill in the channel name you used to generate the token
  final channel =
      "channel_gokidu_rahul"; //---> from firebase -> doc/collection Id chat

  static const platform = MethodChannel('com.gokidu/voipToken');
  String _voipToken = '';


  @override
  void onInit() {
    debugPrint("onInit");
    getPermissions();
    init();
    if (Platform.isIOS) {
      platform.setMethodCallHandler(_handleMethod);
    }
    // startTimer();
    super.onInit();
  }

  // This method is called when the VoIP token is received from the native iOS code
  Future<void> _handleMethod(MethodCall call) async {
    if (call.method == "onVoIPTokenReceived") {
      debugPrint("onVoIPTokenReceived: ${call.arguments}");
      _voipToken = call.arguments;
    }
  }
  Timer? timer;
  var seconds = 0.obs;
  final int _callDuration = 900;

  var remoteUid = Rxn<int>(0);
  var localUserJoined = false.obs;
  var isVideoCall = false.obs;
  var isCameraEnable = true.obs;
  var isMicEnable = true.obs;
  var isSoundEnable = true.obs;
  var remoteVideoState =
      Rxn<RemoteVideoState>(RemoteVideoState.remoteVideoStateStopped);
  var cameraDirection = CameraDirection.cameraFront.obs;
  RtcEngine? engine;

  void startTimer() {
    timer = Timer.periodic(Duration(seconds: 1), (timer) {
        seconds++;
        print("currentSeconds ${seconds}");
        if(seconds>=_callDuration){
          leaveChannel();
        }
    });
  }

  String formatTime(int seconds) {
    int minutes = seconds ~/ 60;
    int secs = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
  }


  updateMic() async {
    await engine!.enableLocalAudio(!isMicEnable.value);
    isMicEnable.value = !isMicEnable.value;
  }

  updateSoundSpeaker() async {
    await engine!.muteRemoteAudioStream(
        uid: remoteUid.value!, mute: isSoundEnable.value);
    isSoundEnable.value = !isSoundEnable.value;
  }

  updateCamera() async {
    await engine!.enableLocalVideo(!isCameraEnable.value);
    isCameraEnable.value = !isCameraEnable.value;
  }

  changeCamera() async {
    debugPrint("changeCamera--> ");
    await engine!.switchCamera();
  }

  getPermissions() async {
    await [Permission.microphone, Permission.camera].request();
  }

  init() async {
    // Create RtcEngine instance
    engine = await createAgoraRtcEngine();
    // Enable the video module
    await engine!.enableVideo();
    // Enable local video preview
    await engine!.startPreview();
    // Initialize RtcEngine and set the channel profile to communication
    await engine!.initialize(const RtcEngineContext(
      appId: appId,
      channelProfile: ChannelProfileType.channelProfileCommunication,
    ));

    registerEventHandlers();
  }

  joinVideoChannel({String? channelId}) async {
    startTimer();
    debugPrint("joinVideoChannel ${channelId} ");
    isVideoCall.value = true;
    await engine!.enableLocalVideo(true);
    await engine!.enableLocalAudio(true);

    await engine!.joinChannel(
      // Join a channel using a temporary token and channel name
      token: token,
      channelId: channelId ?? channel,
      options: const ChannelMediaOptions(
          // Automatically subscribe to all video streams
          autoSubscribeVideo: true,
          // Automatically subscribe to all audio streams
          autoSubscribeAudio: true,
          // Publish camera video
          publishCameraTrack: true,
          // Publish microphone audio
          publishMicrophoneTrack: true,
          // Set user role to clientRoleBroadcaster (broadcaster) or clientRoleAudience (audience)
          clientRoleType: ClientRoleType.clientRoleBroadcaster),
      uid:
          0, // When you set uid to 0, a user name is randomly generated by the engine
    );
  }

  Future<void> joinAudioChannel({String? channelId}) async {
    startTimer();
    isVideoCall.value = false;
    // await engine!.disableVideo();
    // await engine!.stopPreview();

    await engine!.joinChannel(
      token: token,
      channelId: channelId ?? channel,
      options: const ChannelMediaOptions(
        autoSubscribeAudio: true,
        publishMicrophoneTrack: true,
        clientRoleType: ClientRoleType.clientRoleBroadcaster,
      ),
      uid: 0,
    );
  }

  leaveChannel() async {
    await engine!.leaveChannel(options: LeaveChannelOptions());
    localUserJoined.value = false;
    remoteUid.value = null;
    var calls = await FlutterCallkitIncoming.activeCalls();

    await FlutterCallkitIncoming.endCall(calls[0]['id']);
  }

  registerEventHandlers() {
    // Add an event handler
    engine!.registerEventHandler(
      RtcEngineEventHandler(
          // Occurs when the local user joins the channel successfully
          onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
        debugPrint("local user ${connection.localUid} joined");
        localUserJoined.value = true;
      },
          // Occurs when a remote user join the channel
          onUserJoined:
              (RtcConnection connection, int remoteUidd, int elapsed) {
        debugPrint("remote user $remoteUidd joined");
        remoteUid.value = remoteUidd;
      },
          // Occurs when a remote user leaves the channel
          onUserOffline: (RtcConnection connection, int remoteUidd,
              UserOfflineReasonType reason) {
        debugPrint("remote user $remoteUidd left channel");
        remoteUid.value = null;
        // localUserJoined.value=false;
        leaveChannel();
      }, onRemoteVideoStateChanged: (a, b, c, d, e) {
        debugPrint("Remote vide changed --> ${a} ${b} ${c} ${d} ${e}");
        remoteVideoState.value = c;

        // if(c==RemoteVideoState.remoteVideoStateStarting){
        //   updateCamera();
        // }
      }),
    );
  }

  @override
  void onClose() async {
    await engine!.leaveChannel(); // Leave the channel
    await engine!.release(); // Release resources
    timer?.cancel();
  }
}

// FCM Push- DONE
// Push notification host/other device - DONE
// Handle cases- background/ foreground - DONE
// Design Overlay screen - DONE
// Notification sounds/ vibration - DONE

// Accept call event functionality
// Reject call event functionality

//Outgoing call

// IOS

// two person join -> (chat) -> firebase(str) -> Next.js
